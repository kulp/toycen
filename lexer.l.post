int column;

static void c()
{
    for (int i = 0; yytext[i]; i++)
        if (yytext[i] == '\n')
            column = 0;
        else if (yytext[i] == '\t')
            column += TAB_WIDTH - (column % TAB_WIDTH);
        else
            column++;
}

/*
 * We use this routine instead a lex pattern because we don't need
 * to save the matched comment in the `yytext' buffer.
 */
static void skip_comment()
{
    int c1, c2;

    c1 = input();
    c2 = input();

    while (c2 != EOF && !(c1 == '*' && c2 == '/')) {
        if (c1 == '\n')
            ++lineno;
        c1 = c2;
        c2 = input();
    }
}

static int check_identifier(const char *s)
{
    if (hash_table_get(types_hash, s))
        return TYPEDEF_NAME;

    return IDENTIFIER;
}

void lexer_setup()
{
    _debug(2, "%s", __func__);

    /// @todo scope type definitions properly
    if (!types_hash)
        types_hash = hash_table_create(0);
}

void lexer_teardown()
{
    _debug(2, "%s", __func__);
    hash_table_destroy(types_hash);
    types_hash = NULL;
}

/// @todo scope properly
void add_typename(scope_t *scope, const char *type)
{
    hash_table_put(types_hash, type, (void*)1);
}

/* vi:set ts=4 sw=4 et: */
